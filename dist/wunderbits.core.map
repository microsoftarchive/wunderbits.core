{
  "version": 3,
  "file": "wunderbits.core",
  "sources": [
    "wunderbits.core/node_modules/gulp-cjs/node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "wunderbits.core/public/BaseEventEmitter.js",
    "wunderbits.core/public/BaseSingleton.js",
    "wunderbits.core/public/WBClass.js",
    "wunderbits.core/public/WBDeferred.js",
    "wunderbits.core/public/WBEventEmitter.js",
    "wunderbits.core/public/WBMixin.js",
    "wunderbits.core/public/WBPromise.js",
    "wunderbits.core/public/WBSingleton.js",
    "wunderbits.core/public/WBStateModel.js",
    "wunderbits.core/public/index.js",
    "wunderbits.core/public/lib/assert.js",
    "wunderbits.core/public/lib/clone.js",
    "wunderbits.core/public/lib/createUID.js",
    "wunderbits.core/public/lib/debounce.js",
    "wunderbits.core/public/lib/defer.js",
    "wunderbits.core/public/lib/delay.js",
    "wunderbits.core/public/lib/events.js",
    "wunderbits.core/public/lib/extend.js",
    "wunderbits.core/public/lib/forEach.js",
    "wunderbits.core/public/lib/fromSuper.js",
    "wunderbits.core/public/lib/functions.js",
    "wunderbits.core/public/lib/index.js",
    "wunderbits.core/public/lib/inherits.js",
    "wunderbits.core/public/lib/isEqual.js",
    "wunderbits.core/public/lib/merge.js",
    "wunderbits.core/public/lib/size.js",
    "wunderbits.core/public/lib/toArray.js",
    "wunderbits.core/public/lib/when.js",
    "wunderbits.core/public/lib/where.js",
    "wunderbits.core/public/mixins/ControllableMixin.js",
    "wunderbits.core/public/mixins/ObservableHashMixin.js",
    "wunderbits.core/public/mixins/WBBindableMixin.js",
    "wunderbits.core/public/mixins/WBDestroyableMixin.js",
    "wunderbits.core/public/mixins/WBEventsMixin.js",
    "wunderbits.core/public/mixins/WBStateMixin.js",
    "wunderbits.core/public/mixins/WBUtilsMixin.js",
    "wunderbits.core/public/mixins/index.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "'use strict';\n\nvar BaseEmitter = require('./WBEventEmitter').extend({\n  'mixins': [\n    require('./mixins/WBDestroyableMixin'),\n    require('./mixins/WBUtilsMixin'),\n    require('./mixins/ObservableHashMixin')\n  ]\n});\n\nmodule.exports = BaseEmitter;\n",
    "'use strict';\n\nvar BaseSingleton = require('./WBSingleton').extend({\n  'mixins': [\n    require('./mixins/WBEventsMixin'),\n    require('./mixins/WBBindableMixin'),\n    require('./mixins/WBDestroyableMixin'),\n    require('./mixins/WBUtilsMixin'),\n    require('./mixins/ObservableHashMixin')\n  ]\n});\n\nmodule.exports = BaseSingleton;\n",
    "'use strict';\n\nvar inherits = require('./lib/inherits');\nvar extend = require('./lib/extend');\nvar clone = require('./lib/clone');\nvar createUID = require('./lib/createUID');\nvar fromSuper = require('./lib/fromSuper');\n\n// Self-propagating extend function.\n// Create a new class,\n// that inherits from the class found in the `this` context object.\n// This function is meant to be called,\n// in the context of a constructor function.\nfunction extendSelf (protoProps, staticProps) {\n  /* jshint validthis:true */\n\n  var parent = this;\n\n  protoProps = protoProps || {};\n\n  // extract mixins, if any\n  var mixins = protoProps.mixins || [];\n  delete protoProps.mixins;\n\n  // create the derived class\n  var child = inherits(parent, protoProps, staticProps);\n\n  // apply mixins to the derived class\n  var mixin;\n  while (mixins.length) {\n    mixin = mixins.shift();\n    (typeof mixin.applyToClass === 'function') &&\n      mixin.applyToClass(child);\n  }\n\n  // make the child class extensible\n  child.extend = parent.extend || extendSelf;\n  return child;\n}\n\nfunction WBClass (options) {\n\n  var self = this;\n\n  // Assign a unique identifier to the instance\n  self.uid = self.uid || createUID();\n\n  // save options, make sure it's at least an empty object\n  self.options = options || self.options;\n\n  // augment properties from mixins\n  self.augmentProperties();\n\n  // initialize the instance\n  self.initialize.apply(self, arguments);\n\n  // initialize all the mixins, if needed\n  // don't keep this in the initialize,\n  // initialize can be overwritten\n  self.initMixins.apply(self, arguments);\n}\n\nvar proto = {\n\n  'initialize': function () {\n\n    // Return self to allow for subclass to assign\n    // super initializer value to self\n    var self = this;\n    return self;\n  },\n\n  // If any mixins were applied to the prototype, initialize them\n  'initMixins': function () {\n\n    var self = this;\n    var initializers = fromSuper.concat(self, 'initializers');\n\n    var initializer;\n    while (initializers.length) {\n      initializer = initializers.shift();\n      (typeof initializer === 'function') &&\n        initializer.apply(self, arguments);\n    }\n  },\n\n  // If any proerties were defined in the mixins, augment them to the instance\n  'augmentProperties': function () {\n\n    var self = this;\n    var properties = fromSuper.merge(self, 'properties');\n\n    function augmentProperty (property, value) {\n\n      var type = typeof value;\n\n      if (type === 'function') {\n        self[property] = value.call(self);\n      }\n      else if (type === 'object') {\n        self[property] = clone(value, true);\n      }\n      else {\n        self[property] = value;\n      }\n    }\n\n    for (var key in properties) {\n      augmentProperty(key, properties[key]);\n    }\n  }\n};\n\nextend(WBClass.prototype, proto);\nWBClass.extend = extendSelf;\n\nmodule.exports = WBClass;\n",
    "'use strict';\n\nvar WBClass = require('./WBClass');\nvar WBPromise = require('./WBPromise');\nvar assert = require('./lib/assert');\nvar toArray = require('./lib/toArray');\n\nvar states = {\n  'pending': 0,\n  'resolved': 2,\n  'rejected': 4\n};\n\nvar stateNames = {\n  0: ['pending'],\n  2: ['resolved', 'resolve'],\n  4: ['rejected', 'reject']\n};\n\nvar proto = {\n\n  'properties': {\n    '_state': states.pending,\n    '_args': [],\n    'handlers': []\n  },\n\n  'initialize': function (context) {\n    var self = this;\n    self._context = context;\n  },\n\n  'state': function () {\n    var self = this;\n    return stateNames[self._state][0];\n  },\n\n  'trigger': function (withContext) {\n\n    var self = this;\n    if (self._state === states.pending) {\n      return;\n    }\n\n    var handlers = self.handlers, handle;\n    while (handlers.length) {\n      handle = handlers.shift();\n      self.invoke(handle, withContext || self._context);\n    }\n  },\n\n  'invoke': function (deferredResponse, withContext) {\n\n    var self = this;\n    var state = self._state;\n    var context = deferredResponse.context || withContext || self;\n    var args = deferredResponse.args;\n\n    self._args.forEach(function (arg) {\n      // send single arguments as the item, otherwise send it as an array\n      args.push(arg);\n    });\n\n    var type = deferredResponse.type;\n    var isCompleted = (type === 'then') ||\n      (type === 'done' && state === states.resolved) ||\n      (type === 'fail' && state === states.rejected);\n\n    isCompleted && deferredResponse.fn.apply(context, args);\n  },\n\n  'promise': function () {\n    var self = this;\n    self._promise = self._promise || new WBPromise(this);\n    return self._promise;\n  }\n};\n\n['then', 'done', 'fail'].forEach(function (method) {\n  proto[method] = function () {\n\n    var self = this;\n\n    // store references to the context, callbacks, and arbitrary arguments\n    var args = toArray(arguments);\n    var fn = args.shift();\n    var context = args.shift();\n\n    assert.function(fn, method + ' accepts only functions');\n\n    self.handlers.push({\n      'type': method,\n      'context': context,\n      'fn': fn,\n      'args': args\n    });\n\n    // if the defered is not pending anymore, call the callbacks\n    self.trigger();\n\n    return self;\n  };\n});\n\n// Alias `always` to `then` on Deferred's prototype\nproto.always = proto.then;\n\nfunction resolver (state, isWith, fnName) {\n  return function complete () {\n\n    var self = this;\n\n    if (!(self instanceof WBDeferred)) {\n      throw new Error(fnName + ' invoked with wrong context');\n    }\n\n    // can't change state once resolved or rejected\n    if (self._state !== states.pending) {\n      return self;\n    }\n\n    self._args = toArray(arguments);\n    var context = isWith ? self._args.shift() : undefined;\n\n    self._state = state;\n    self.trigger(context);\n\n    return self;\n  };\n}\n\n[states.resolved, states.rejected].forEach(function (state) {\n  var fnName = stateNames[state][1];\n  proto[fnName] = resolver(state, false, fnName);\n  proto[fnName + 'With'] = resolver(state, true, fnName);\n});\n\nvar WBDeferred = WBClass.extend(proto);\nmodule.exports = WBDeferred;\n",
    "'use strict';\n\nvar WBEventEmitter = require('./WBClass').extend({\n  'mixins': [\n    require('./mixins/WBBindableMixin'),\n    require('./mixins/WBEventsMixin')\n  ]\n});\n\nmodule.exports = WBEventEmitter;\n",
    "'use strict';\n\nvar extend = require('./lib/extend');\nvar clone = require('./lib/clone');\nvar assert = require('./lib/assert');\nvar WBSingleton = require('./WBSingleton');\n\nvar WBMixin = WBSingleton.extend({\n\n  // Apply the mixin to an instance of a class\n  'applyTo': function (instance) {\n\n    var behavior = clone(this.Behavior, true);\n\n    // apply mixin's initialize & remove it from the instance\n    var initializer;\n    if (typeof behavior.initialize === 'function') {\n      initializer = behavior.initialize;\n      delete behavior.initialize;\n    }\n\n    // augment mixin's properties object into the instance\n    var properties = behavior.properties;\n    delete behavior.properties;\n\n    // mixin the behavior\n    extend(instance, behavior);\n\n    // apply the initializer, if any\n    initializer && initializer.apply(instance);\n\n    // augment proerties to the instance\n    properties && extend(instance, properties);\n\n    return instance;\n  },\n\n  // Apply the mixin to the class directly\n  'applyToClass': function (klass) {\n\n    // validate class\n    assert.class(klass, 'applyToClass expects a class');\n\n    var proto = klass.prototype;\n    var behavior = clone(this.Behavior, true);\n\n    // cache the mixin's initializer, to be applied later\n    var initialize = behavior.initialize;\n    if (typeof initialize === 'function') {\n      (!proto.hasOwnProperty('initializers')) && (proto.initializers = []);\n      proto.initializers.push(initialize);\n      delete behavior.initialize;\n    }\n\n    var properties = behavior.properties;\n    delete behavior.properties;\n\n    // extend the prototype\n    extend(proto, behavior);\n\n    // cache the properties, to be applied later\n    (!proto.hasOwnProperty('properties')) && (proto.properties = {});\n    properties && extend(proto.properties, properties);\n\n    return klass;\n  }\n});\n\n// The only real change from a simple singleton is\n// the altered extend class method, which will save\n// \"mixinProps\" into a specific member, for easy\n// and clean application using #applyTo\nWBMixin.extend = function (mixinProps, staticProps) {\n\n  mixinProps || (mixinProps = {});\n  staticProps || (staticProps = {});\n\n  var current = clone(this.Behavior, true);\n  staticProps.Behavior = extend(current, mixinProps);\n  var mixin = WBSingleton.extend.call(this, staticProps);\n\n  mixin.extend = WBMixin.extend;\n\n  return mixin;\n};\n\nmodule.exports = WBMixin;\n",
    "'use strict';\n\nvar WBClass = require('./WBClass');\n\nfunction proxy (name) {\n  return function () {\n    var deferred = this.deferred;\n    deferred[name].apply(deferred, arguments);\n    return this;\n  };\n}\n\nvar proto = {\n  'constructor': function (deferred) {\n    this.deferred = deferred;\n  },\n\n  'promise': function () {\n    return this;\n  },\n\n  'state': function () {\n    return this.deferred.state();\n  }\n};\n\n[\n  'done',\n  'fail',\n  'then'\n].forEach(function (name) {\n  proto[name] = proxy(name);\n});\n\nproto.always = proto.then;\n\nmodule.exports = WBClass.extend(proto);\n",
    "'use strict';\n\nvar extend = require('./lib/extend');\nvar createUID = require('./lib/createUID');\n\nfunction applyMixins (mixins, instance) {\n  var mixin;\n  while (mixins.length) {\n    mixin = mixins.shift();\n    (typeof mixin.applyTo === 'function') &&\n      mixin.applyTo(instance);\n  }\n}\n\nfunction extendSelf (staticProps) {\n  /* jshint validthis:true */\n\n  staticProps = staticProps || {};\n\n  // extend from the base singleton\n  var BaseSingleton = this || WBSingleton;\n\n  // create a new instance\n  Ctor.prototype = BaseSingleton;\n  var singleton = new Ctor();\n\n  // extract mixins\n  var mixins = staticProps.mixins || [];\n  staticProps.mixins = undefined;\n\n  // apply mixins to the instance\n  applyMixins(mixins, singleton);\n\n  // append the static properties to the singleton\n  extend(singleton, staticProps);\n\n  // make the singleton extendable\n  // Do this after applying mixins,\n  // to ensure that no mixin can override `extend` method\n  singleton.extend = extendSelf;\n\n  // every signleton gets a UID\n  singleton.uid = createUID();\n\n  return singleton;\n}\n\nvar Ctor = function () {};\nCtor.prototype = {\n  'extend': extendSelf\n};\n\nvar WBSingleton = new Ctor();\nmodule.exports = WBSingleton;\n",
    "'use strict';\n\nvar WBClass = require('./WBClass');\n\nvar WBDestroyableMixin = require('./mixins/WBDestroyableMixin');\nvar originalDestroy = WBDestroyableMixin.Behavior.destroy;\n\nvar WBStateModel = WBClass.extend({\n\n  'mixins': [\n    require('./mixins/WBEventsMixin'),\n    require('./mixins/WBStateMixin'),\n    require('./mixins/WBBindableMixin'),\n    WBDestroyableMixin\n  ],\n\n  'initialize': function (attributes) {\n\n    var self = this;\n\n    if (attributes) {\n      self.attributes = attributes;\n    }\n  },\n\n  'sync':  function (method, instance, options) {\n    if (options && typeof options.success === 'function') {\n      options.success();\n    }\n  },\n\n  'fetch': function (options) {\n    var self = this;\n    var success = options.success;\n    var model = this;\n    options.success = function (resp) {\n      if (!model.set(resp, options)) return false;\n      if (success) success(model, resp, options);\n      model.trigger('sync', model, resp, options);\n    };\n    return self.sync('read', self, options);\n  },\n\n  'save': function (key, val, options) {\n\n    var self = this;\n    if (!self.destroying) {\n      // set the attributes\n      self.set(key, val, options);\n      // sync\n      (typeof key === 'object') && (options = val);\n      self.sync('update', self, options);\n    }\n    return self;\n  },\n\n  'destroy': function (options) {\n\n    var self = this;\n    if (!self.destroying) {\n      self.destroying = true;\n      originalDestroy.call(self, options);\n      self.attributes = {};\n      self.sync('delete', self, options);\n    }\n  }\n});\n\nmodule.exports = WBStateModel;\n",
    "'use strict';\n\nmodule.exports = {\n  'lib': require('./lib'),\n  'BaseEventEmitter': require('./BaseEventEmitter'),\n  'BaseSingleton': require('./BaseSingleton'),\n  'WBClass': require('./WBClass'),\n  'WBDeferred': require('./WBDeferred'),\n  'WBEventEmitter': require('./WBEventEmitter'),\n  'WBMixin': require('./WBMixin'),\n  'WBSingleton': require('./WBSingleton'),\n  'WBStateModel': require('./WBStateModel'),\n  'mixins': require('./mixins')\n};\n",
    "'use strict';\n\nfunction assert (condition, message) {\n  if (!condition) {\n    throw new Error(message || '');\n  }\n}\n\nvar nativeIsArray = Array.isArray;\nassert.empty = function (object, message) {\n  var keys = nativeIsArray(object) ? object : Object.keys(object);\n  assert(keys.length === 0, message);\n};\n\nassert.array = function (array, message) {\n  assert(nativeIsArray(array), message);\n};\n\nassert.class = function (klass, message) {\n  var proto = klass.prototype;\n  assert(proto && proto.constructor === klass, message);\n};\n\nvar types = [\n  'undefined',\n  'boolean',\n  'number',\n  'string',\n  'function',\n  'object'\n];\n\nfunction typecheck (type) {\n  assert[type] = function (o, message) {\n    assert(typeof o === type, message);\n  };\n}\n\nwhile (types.length) {\n  typecheck(types.shift());\n}\n\nmodule.exports = assert;",
    "'use strict';\n\nvar nativeIsArray = Array.isArray;\n\nfunction cloneArray (arr, isDeep) {\n  arr = arr.slice();\n  if (isDeep) {\n    var newArr = [], value;\n    while (arr.length) {\n      value = arr.shift();\n      value = (value instanceof Object) ? clone(value, isDeep) : value;\n      newArr.push(value);\n    }\n    arr = newArr;\n  }\n  return arr;\n}\n\nfunction cloneDate (date) {\n  return new Date(date.getTime());\n}\n\nfunction cloneObject (source, isDeep) {\n  var object = {};\n  for (var key in source) {\n    if (source.hasOwnProperty(key)) {\n      var value = source[key];\n      if (value instanceof Date) {\n        object[key] = cloneDate(value);\n      } else if (typeof value === 'object' && value !== null && isDeep) {\n        object[key] = clone(value, isDeep);\n      } else {\n        object[key] = value;\n      }\n    }\n  }\n  return object;\n}\n\nfunction clone (obj, isDeep) {\n\n  if (nativeIsArray(obj)) {\n    return cloneArray(obj, isDeep);\n  }\n\n  return cloneObject(obj, isDeep);\n}\n\nmodule.exports = clone;\n",
    "'use strict';\n\nfunction replacer (match) {\n  var rand = Math.random() * 16 | 0;\n  var chr = (match === 'x') ? rand : (rand & 0x3 | 0x8);\n  return chr.toString(16);\n}\n\nfunction createUID (prefix) {\n  var uid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, replacer);\n  return String(!prefix ? '' : prefix) + uid;\n}\n\nmodule.exports = createUID;\n",
    "'use strict';\n\n// Returns a function, that, as long as it continues to be invoked, will not\n// be triggered. The function will be called after it stops being called for\n// N milliseconds. If `immediate` is passed, trigger the function on the\n// leading edge, instead of the trailing.\n// From: http://davidwalsh.name/function-debounce\nfunction debounce (fn, wait, immediate) {\n  var timeout;\n  return function() {\n    var context = this, args = arguments;\n    var later = function() {\n      timeout = null;\n      if (!immediate) {\n        fn.apply(context, args);\n      }\n    };\n    var callNow = immediate && !timeout;\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n    if (callNow) {\n      fn.apply(context, args);\n    }\n  };\n}\n\nmodule.exports = debounce;",
    "'use strict';\n\nvar toArray = require('./toArray');\nvar delay = require('./delay');\n\nfunction defer (fn) {\n  var args = toArray(arguments);\n  args[0] = 1;\n  args.unshift(fn);\n  return delay.apply(null, args);\n}\n\nmodule.exports = defer;\n",
    "'use strict';\n\nvar toArray = require('./toArray');\n\nfunction delay (fn, time, context) {\n  var args = toArray(arguments, 3);\n  return setTimeout(function () {\n\n    var destroyed = context && context.destroyed;\n    !destroyed && fn.apply(context, args);\n  }, time);\n}\n\nmodule.exports = delay;\n",
    "'use strict';\n\nvar assert = require('./assert');\nvar toArray = require('./toArray');\nvar clone = require('./clone');\n\nvar eventSplitter = /\\s+/;\n\nvar validationErrors = {\n  'trigger': 'Cannot trigger event(s) without event name(s)',\n  'events': 'Cannot bind/unbind without valid event name(s)',\n  'callback': 'Cannot bind/unbind to an event without valid callback function'\n};\n\nvar events = {\n\n  'properties': {\n    '_events': {},\n    '_cache': {}\n  },\n\n  'on': function (events, callback, context) {\n\n    var self = this;\n\n    // validate arguments\n    assert.string(events, validationErrors.events);\n    assert.function(callback, validationErrors.callback);\n\n    // loop through the events & bind them\n    self.iterate(events, function (name) {\n      // keep the binding\n      self.bind(name, callback, context);\n\n      // if this was a published event, do an immediate trigger\n      var cache = self._cache;\n      if (cache[name]) {\n        callback.apply(context || self, cache[name]);\n      }\n    });\n\n    return self;\n  },\n\n  'off': function (events, callback, context) {\n\n    var self = this;\n\n    // validate events only if a truthy value is passed\n    events && assert.string(events, validationErrors.events);\n\n    // if no arguments were passed, unbind everything\n    if (!events && !callback && !context) {\n      self._events = {};\n      return self;\n    }\n\n    // if no events are passed, unbind all events with this callback\n    events = events || Object.keys(self._events);\n\n    // loop through the events & bind them\n    self.iterate(events, function (name) {\n      self.unbind(name, callback, context);\n    });\n\n    return self;\n  },\n\n  'once': function (events, callback, context) {\n\n    var self = this;\n    var args = toArray(arguments);\n\n    // create a one time binding\n    args[1] = function () {\n      self.off.apply(self, args);\n      callback.apply(context || self, arguments);\n    };\n\n    self.on.apply(self, args);\n\n    return self;\n  },\n\n  'publish': function (events) {\n\n    var self = this;\n    var args = toArray(arguments);\n\n    // validate events\n    assert.string(events, validationErrors.events);\n\n    self.iterate(events, function (name) {\n      var cache = self._cache;\n      if (!cache[name]) {\n        cache[name] = args.slice(1);\n        args[0] = name;\n        self.trigger.apply(self, args);\n      }\n    });\n\n    return self;\n  },\n\n  'unpublish': function (events) {\n\n    var self = this;\n\n    // validate events\n    assert.string(events, validationErrors.events);\n\n    // remove the cache for the events\n    self.iterate(events, function (name) {\n      self._cache[name] = undefined;\n    });\n\n    return self;\n  },\n\n  'unpublishAll': function () {\n    var self = this;\n    self._cache = {};\n    return self;\n  },\n\n  'trigger': function (events) {\n\n    var self = this;\n\n    // validate arguments\n    assert.string(events, validationErrors.trigger);\n\n    // loop through the events & trigger them\n    var params = toArray(arguments, 1);\n    self.iterate(events, function (name) {\n      self.triggerEvent(name, params);\n    });\n\n    return self;\n  },\n\n  'triggerEvent': function (name, params) {\n\n    var self = this;\n    var events = self._events || {};\n\n    // call sub-event handlers\n    var current = [];\n    var fragments = name.split(':');\n    while (fragments.length) {\n      current.push(fragments.shift());\n      name = current.join(':');\n      if (name in events) {\n        self.triggerSection(name, fragments, params);\n      }\n    }\n  },\n\n  'triggerSection': function (name, fragments, params) {\n\n    var self = this;\n    var events = self._events || {};\n    var bucket = events[name] || [];\n\n    bucket.forEach(function (item) {\n      var args;\n      if (fragments.length) {\n        args = clone(params);\n        args.unshift(fragments);\n      }\n      item.callback.apply(item.context || self, args || params);\n    });\n  },\n\n  'iterate': function (events, iterator) {\n\n    var self = this;\n\n    if (typeof events === 'string') {\n      events = events.split(eventSplitter);\n    } else {\n      assert.array(events);\n    }\n\n    while (events.length) {\n      iterator.call(self, events.shift());\n    }\n  },\n\n  'bind': function (name, callback, context) {\n\n    var self = this;\n\n    // store the reference to the callback + context\n    var events = self._events || {};\n    var bucket = events[name] || (events[name] = []);\n    bucket.push({\n      'callback': callback,\n      'context': context\n    });\n\n    return self;\n  },\n\n  'unbind': function (name, callback, context) {\n\n    var self = this;\n\n    // lookup the reference to handler & remove it\n    var events = self._events;\n    var bucket = events[name] || [];\n    var retain = [];\n\n    // loop through the handlers\n    var i = -1, l = bucket.length, item;\n    while (++i < l) {\n      item = bucket[i];\n      if ((callback && callback !== item.callback) ||\n          (context && context !== item.context)) {\n        retain.push(item);\n      }\n    }\n\n    // flush out detached handlers\n    events[name] = retain;\n\n    return self;\n  }\n};\n\nmodule.exports = events;\n",
    "'use strict';\n\nvar toArray = require('./toArray');\nvar merge = require('./merge');\nvar assert = require('./assert');\n\nfunction extend () {\n\n  // convert the argument list into an array\n  var args = toArray(arguments);\n\n  // validate input\n  assert(args.length > 0, 'extend expect one or more objects');\n\n  // loop through the arguments\n  // & merging them recursively\n  var object = args.shift();\n  while (args.length) {\n    merge(object, args.shift());\n  }\n\n  return object;\n}\n\nmodule.exports = extend;\n",
    "'use strict';\n\nfunction forArray (array, iterator, context) {\n  for (var i = 0, l = array.length; i < l; i++) {\n    if (iterator.call(context, array[i], i, array) === false) {\n      return;\n    }\n  }\n}\n\nfunction forObject (object, iterator, context) {\n  for (var key in object) {\n    if (object.hasOwnProperty(key)) {\n      if (iterator.call(context, object[key], key) === false) {\n        return;\n      }\n    }\n  }\n}\n\nfunction forEach (collection, iterator, context) {\n  var handler = Array.isArray(collection) ? forArray : forObject;\n  handler(collection, iterator, context);\n}\n\nmodule.exports = forEach;\n",
    "'use strict';\n\nvar merge = require('./merge');\nvar extend = require('./extend');\n\nfunction mergeFromSuper (instance, key) {\n\n  var constructor = instance.constructor;\n  var proto = constructor.prototype;\n\n  var baseData = {};\n  if (instance.hasOwnProperty(key)) {\n    baseData = instance[key];\n  } else if (proto.hasOwnProperty(key)) {\n    baseData = proto[key];\n  }\n\n  var _super = constructor && constructor.__super__;\n  if (_super) {\n    baseData = merge(mergeFromSuper(_super, key), baseData);\n  }\n\n  return extend({}, baseData);\n}\n\nfunction concatFromSuper (instance, key) {\n\n  var constructor = instance.constructor;\n  var proto = constructor.prototype;\n\n  var baseData = [];\n  if (instance.hasOwnProperty(key)) {\n    baseData = instance[key];\n  } else if (proto.hasOwnProperty(key)) {\n    baseData = proto[key];\n  }\n\n  var _super = constructor && constructor.__super__;\n  if (_super) {\n    baseData = [].concat(concatFromSuper(_super, key), baseData);\n  }\n\n  return [].concat(baseData);\n}\n\nmodule.exports = {\n  'merge': mergeFromSuper,\n  'concat': concatFromSuper\n};\n",
    "'use strict';\n\nfunction functions (obj) {\n  var funcs = [];\n  for (var key in obj) {\n    if (typeof obj[key] === 'function') {\n      funcs.push(key);\n    }\n  }\n  return funcs;\n}\n\nmodule.exports = functions;\n",
    "'use strict';\n\nmodule.exports = {\n  'assert': require('./assert'),\n  'clone': require('./clone'),\n  'createUID': require('./createUID'),\n  'debounce': require('./debounce'),\n  'defer': require('./defer'),\n  'delay': require('./delay'),\n  'events': require('./events'),\n  'extend': require('./extend'),\n  'forEach': require('./forEach'),\n  'fromSuper': require('./fromSuper'),\n  'functions': require('./functions'),\n  'inherits': require('./inherits'),\n  'isEqual': require('./isEqual'),\n  'merge': require('./merge'),\n  'size': require('./size'),\n  'toArray': require('./toArray'),\n  'when': require('./when'),\n  'where': require('./where')\n};",
    "'use strict';\n\nvar extend = require('./extend');\n\n// Helper function to correctly set up the prototype chain, for subclasses.\n// Similar to `goog.inherits`, but uses a hash of prototype properties and\n// class properties to be extended.\nfunction inherits (parent, protoProps, staticProps) {\n\n  var child;\n\n  // The constructor function for the new subclass is either defined by you\n  // (the \"constructor\" property in your `extend` definition), or defaulted\n  // by us to simply call `super()`.\n  if (protoProps && protoProps.hasOwnProperty('constructor')) {\n    child = protoProps.constructor;\n  }\n  else {\n    child = function () {\n      return parent.apply(this, arguments);\n    };\n  }\n\n  // Inherit class (static) properties from parent.\n  extend(child, parent);\n\n  // Set the prototype chain to inherit from `parent`, without calling\n  // `parent`'s constructor function.\n  child.prototype = Object.create(parent.prototype);\n\n  // Add prototype properties (instance properties) to the subclass,\n  // if supplied.\n  extend(child.prototype, protoProps);\n\n  // Correctly set child's `prototype.constructor`.\n  child.prototype.constructor = child;\n\n  // Add static properties to the constructor function, if supplied.\n  extend(child, staticProps);\n\n  // Set a convenience property\n  // in case the parent's prototype is needed later.\n  child.__super__ = parent.prototype;\n\n  return child;\n}\n\nmodule.exports = inherits;\n",
    "'use strict';\n\n// TODO: implement deepEqual\nfunction isEqual (a, b) {\n  return a === b;\n}\n\nmodule.exports = isEqual;\n",
    "'use strict';\n\nvar toArray = require('./toArray');\n\nfunction merge (object, source) {\n  var sources = toArray(arguments, 1);\n  while (sources.length) {\n    source = sources.shift();\n    for (var key in source) {\n      if (source.hasOwnProperty(key)) {\n        object[key] = source[key];\n      }\n    }\n  }\n  return object;\n}\n\nmodule.exports = merge;\n",
    "'use strict';\n\nfunction size (collection) {\n  !Array.isArray(collection) && (collection = Object.keys(collection));\n  return collection.length;\n}\n\nmodule.exports = size;\n",
    "'use strict';\n\nvar slice = Array.prototype.slice;\nfunction toArray (obj, skip) {\n  return slice.call(obj, skip || 0);\n}\n\nmodule.exports = toArray;\n",
    "'use strict';\n\nvar WBDeferred = require('../WBDeferred');\nvar toArray = require('./toArray');\n\nfunction When () {\n\n  var context = this;\n  var main = new WBDeferred(context);\n  var deferreds = toArray(arguments);\n\n  // support passing an array of deferreds, to avoid `apply`\n  if (deferreds.length === 1 && Array.isArray(deferreds[0])) {\n    deferreds = deferreds[0];\n  }\n\n  var count = deferreds.length;\n  var args = new Array(count);\n\n  function Fail () {\n    main.rejectWith(this);\n  }\n\n  function Done () {\n\n    if (main.state() === 'rejected') {\n      return;\n    }\n\n    var index = count - deferreds.length - 1;\n    args[index] = toArray(arguments);\n\n    if (deferreds.length) {\n      var next = deferreds.shift();\n      next.done(Done);\n    } else {\n      args.unshift(this);\n      main.resolveWith.apply(main, args);\n    }\n  }\n\n  if (deferreds.length) {\n\n    deferreds.forEach(function (deferred) {\n      deferred.fail(Fail);\n    });\n\n    var current = deferreds.shift();\n    current.done(Done);\n  } else {\n    main.resolve();\n  }\n\n  return main.promise();\n}\n\nmodule.exports = When;\n",
    "'use strict';\n\nvar forEach = require('./forEach');\n\nfunction where (collection, properties) {\n  var matches = [];\n  forEach(collection, function (item) {\n    for (var key in properties) {\n      if (item[key] !== properties[key]) {\n        return;\n      }\n      matches.push(item);\n    }\n  });\n  return matches;\n}\n\nmodule.exports = where;\n",
    "'use strict';\n\nvar WBMixin = require('../WBMixin');\nvar fromSuper = require('../lib/fromSuper');\n\nvar ControllableMixin = WBMixin.extend({\n\n  'initialize': function () {\n\n    var self = this;\n\n    self.controllers = [];\n    self.implemented = [];\n\n    self.implements = fromSuper.concat(self, 'implements');\n    self.createControllerInstances();\n\n    self.bindOnceTo(self, 'destroy', 'destroyControllers');\n  },\n\n  'createControllerInstances': function () {\n\n    var self = this;\n\n    var Controllers = self.implements;\n    if (typeof Controllers === 'function') {\n      Controllers = Controllers.call(self);\n    }\n\n    var ControllerClass, controllerInstance, i;\n\n    // the order in which the controllers are implemented is important!\n    for (i = Controllers.length; i--;) {\n      ControllerClass = Controllers[i];\n\n      // If we have already implemented a controller that inherits from\n      // this controller, we don't need another one...\n      if (self.implemented.indexOf(ControllerClass.toString()) < 0) {\n\n        controllerInstance = new ControllerClass(self);\n        self.controllers.push(controllerInstance);\n        controllerInstance.parent = self;\n\n        self.trackImplementedSuperConstructors(ControllerClass);\n      }\n    }\n\n    return self.implemented;\n  },\n\n  'trackImplementedSuperConstructors': function (Controller) {\n\n    var self = this;\n    var _super = Controller.__super__;\n    var superConstructor = _super && _super.constructor;\n\n    if (superConstructor) {\n      self.implemented.push(superConstructor.toString());\n      self.trackImplementedSuperConstructors(superConstructor);\n    }\n  },\n\n  'destroyControllers': function () {\n\n    var self = this;\n\n    // Loop and destroy\n    var controller;\n    var controllers = self.controllers;\n\n    while (controllers.length) {\n      // A controller can exist multiple times in the list,\n      // since it's based on the event name,\n      // so make sure to only destroy each one once\n      controller = controllers.shift();\n      controller.destroyed || controller.destroy();\n    }\n  }\n});\n\nmodule.exports = ControllableMixin;\n",
    "'use strict';\n\nvar WBMixin = require('../WBMixin');\nvar fromSuper = require('../lib/fromSuper');\nvar clone = require('../lib/clone');\n\nvar ObservableHashMixin = WBMixin.extend({\n\n  'initialize': function () {\n\n    var self = this;\n\n    var observesHash = fromSuper.merge(self, 'observes');\n    for (var target in observesHash) {\n      self.bindToTarget(self.resolveTarget(target), observesHash[target]);\n    }\n  },\n\n  'bindToTarget': function (target, events) {\n\n    var self = this;\n\n    for (var eventString in events) {\n      self.bindHandlers(target, eventString, events[eventString]);\n    }\n  },\n\n  'bindHandlers': function (target, eventString, handlers) {\n\n    var self = this;\n\n    if (typeof handlers === 'string') {\n      handlers = [handlers];\n    } else {\n      handlers = clone(handlers);\n    }\n\n    while (handlers.length) {\n      self.bindTo(target, eventString, handlers.shift());\n    }\n  },\n\n  'resolveTarget': function (key) {\n\n    var self = this;\n\n    // allow observing self\n    if (key === 'self') {\n      return self;\n    }\n\n    var target = self[key];\n    if (!target && typeof key === 'string' && key.indexOf('.') > -1) {\n      key = key.split('.');\n      target = self;\n      while (key.length && target) {\n        target = target[key.shift()];\n      }\n    }\n\n    return target;\n  }\n\n});\n\nmodule.exports = ObservableHashMixin;\n",
    "'use strict';\n\nvar WBMixin = require('../WBMixin');\n// var assert = require('../lib/assert');\nvar createUID = require('../lib/createUID');\n\nvar WBBindableMixin = WBMixin.extend({\n\n  'properties': {\n    '_bindings': {},\n    '_namedEvents': {}\n  },\n\n  // keeps callback closure in own execution context with\n  // only callback and context\n  'callbackFactory': function  (callback, context) {\n\n    var bindCallback;\n\n    var forString = function stringCallback () {\n      context[callback].apply(context, arguments);\n    };\n\n    var forFunction = function functionCallback () {\n      callback.apply(context, arguments);\n    };\n\n    if (typeof callback === 'string') {\n      bindCallback = forString;\n      // cancel alternate closure immediately\n      forFunction = null;\n    }\n    else {\n      bindCallback = forFunction;\n      forString = null;\n    }\n\n    return bindCallback;\n  },\n\n  'bindTo': function (target, event, callback, context) {\n\n    var self = this;\n    self.checkBindingArgs.apply(self, arguments);\n\n    // default to self if context not provided\n    context = context || self;\n\n    // if this binding already made, return it\n    var bound = self.isAlreadyBound(target, event, callback, context);\n    if (bound) {\n      return bound;\n    }\n\n\n    var callbackFunc, args;\n\n    // if a jquery object\n    if (target.constructor && target.constructor.fn && target.constructor.fn.on === target.on) {\n      // jquery does not take context in .on()\n      // cannot assume on takes context as a param for bindable object\n      // create a callback which will apply the original callback in the correct context\n      callbackFunc = self.callbackFactory(callback, context);\n      args = [event, callbackFunc];\n    } else {\n      // Backbone accepts context when binding, simply pass it on\n      callbackFunc = (typeof callback === 'string') ? context[callback] : callback;\n      args = [event, callbackFunc, context];\n    }\n\n    // create binding on target\n    target.on.apply(target, args);\n\n    var binding = {\n      'uid': createUID(),\n      'target': target,\n      'event': event,\n      'originalCallback': callback,\n      'callback': callbackFunc,\n      'context': context\n    };\n\n    self._bindings[binding.uid] = binding;\n    self.addToNamedBindings(event, binding);\n\n    return binding;\n  },\n\n  'bindOnceTo': function (target, event, callback, context) {\n\n    var self = this;\n    self.checkBindingArgs.apply(self, arguments);\n\n    context = context || self;\n\n    // if this binding already made, return it\n    var bound = self.isAlreadyBound(target, event, callback, context);\n    if (bound) {\n      return bound;\n    }\n\n\n    // this is a wrapper\n    var onceBinding = function () {\n\n      ((typeof callback === 'string') ? context[callback] : callback).apply(context, arguments);\n      self.unbindFrom(binding);\n    };\n\n    var binding = {\n      'uid': createUID(),\n      'target': target,\n      'event': event,\n      'originalCallback': callback,\n      'callback': onceBinding,\n      'context': context\n    };\n\n    target.on(event, onceBinding, context);\n\n    self._bindings[binding.uid] = binding;\n    self.addToNamedBindings(event, binding);\n\n    return binding;\n  },\n\n  'unbindFrom': function (binding) {\n\n    var self = this;\n\n    var uid = binding && binding.uid;\n    if (!binding || (typeof uid !== 'string')) {\n      throw new Error('Cannot unbind from undefined or invalid binding');\n    }\n\n    var event = binding.event;\n    var context = binding.context;\n    var callback = binding.callback;\n    var target = binding.target;\n\n    // a binding object with only uid, i.e. a destroyed/unbound\n    // binding object has been passed - just do nothing\n    if (!event || !callback || !target || !context) {\n      return;\n    }\n\n    target.off(event, callback, context);\n\n    // clean up binding object, but keep uid to\n    // make sure old bindings, that have already been\n    // cleaned, are still recognized as bindings\n    for (var key in binding) {\n      if (key !== 'uid') {\n        delete binding[key];\n      }\n    }\n\n    delete self._bindings[uid];\n\n    var namedEvents = self._namedEvents;\n    var events = namedEvents[event];\n\n    if (events) {\n      var cloned = events && events.slice(0);\n      for (var i = events.length - 1; i >= 0; i--) {\n        if (events[i].uid === uid) {\n          cloned.splice(i, 1);\n        }\n      }\n\n      namedEvents[event] = cloned;\n    }\n\n    return;\n  },\n\n  'unbindFromTarget': function (target) {\n\n    var self = this;\n\n    if (!target || (typeof target.on !== 'function')) {\n      throw new Error('Cannot unbind from undefined or invalid binding target');\n    }\n\n    var binding;\n    for (var key in self._bindings) {\n      binding = self._bindings[key];\n      if (binding.target === target) {\n        self.unbindFrom(binding);\n      }\n    }\n  },\n\n  'unbindAll': function () {\n\n    var self = this;\n\n    var binding;\n    for (var key in self._bindings) {\n      binding = self._bindings[key];\n      self.unbindFrom(binding);\n    }\n  },\n\n  'checkBindingArgs': function (target, event, callback, context) {\n\n    context = context || this;\n\n    // do not change these messages without updating the specs\n    if (!target || (typeof target.on !== 'function')) {\n      throw new Error('Cannot bind to undefined target or target without #on method');\n    }\n\n    if (!event || (typeof event !== 'string')) {\n      throw new Error('Cannot bind to target event without event name');\n    }\n\n    if (!callback || ((typeof callback !== 'function') && (typeof callback !== 'string'))) {\n      throw new Error('Cannot bind to target event without a function or method name as callback');\n    }\n\n    if ((typeof callback === 'string') && !context[callback]) {\n      throw new Error('Cannot bind to target using a method name that does not exist for the context');\n    }\n  },\n\n  'isAlreadyBound': function (target, event, callback, context) {\n\n    var self = this;\n    // check for same callback on the same target instance\n    // return early withthe event binding\n    var events = self._namedEvents[event];\n    if (events) {\n      for (var i = 0, max = events.length; i < max; i++) {\n\n        var current = events[i] || {};\n\n        // the below !boundTarget check seems unreachable\n        // was added in this commit of the web app: c75d5077c0a8629b60cb6dd1cd78d3bc77fcac48\n        // need to ask Adam under what conditions this would be possible\n        var boundTarget = current.target;\n        if (!boundTarget) {\n          return false;\n        }\n\n        var targetBound = target.uid ? target.uid === boundTarget.uid : false;\n        if (current.originalCallback === callback &&\n            current.context === context && targetBound) {\n          return current;\n        }\n      }\n    }\n\n    return false;\n  },\n\n  'addToNamedBindings': function (event, binding) {\n\n    var self = this;\n    if (!self._namedEvents[event]) {\n      self._namedEvents[event] = [];\n    }\n    self._namedEvents[event].push(binding);\n  }\n});\n\nmodule.exports = WBBindableMixin;\n",
    "'use strict';\n\nvar forEach = require('../lib/forEach');\nvar WBMixin = require('../WBMixin');\n\nfunction noop () {}\n\nfunction Call (fn) {\n  var self = this;\n  (typeof fn === 'string') && (fn = self[fn]);\n  (typeof fn === 'function') && fn.call(self);\n}\n\nvar cleanupMethods = ['unbind', 'unbindAll', 'onDestroy'];\n\nvar WBDestroyableMixin = WBMixin.extend({\n\n  'destroy': function () {\n\n    var self = this;\n\n    self.trigger('destroy');\n\n    // clean up\n    forEach(cleanupMethods, Call, self);\n\n    self.destroyObject(self);\n\n    self.destroyed = true;\n  },\n\n  'destroyObject': function (object) {\n\n    var self = this;\n    for (var key in object) {\n      self.destroyKey(key, object);\n    }\n  },\n\n  'destroyKey': function (key, context) {\n\n    if (context.hasOwnProperty(key) && key !== 'uid' && key !== 'cid') {\n      // make functions noop\n      if (typeof context[key] === 'function') {\n        context[key] = noop;\n      }\n      // and others undefined\n      else {\n        context[key] = undefined;\n      }\n    }\n  }\n});\n\nmodule.exports = WBDestroyableMixin;\n",
    "'use strict';\n\nvar WBMixin = require('../WBMixin');\nvar events = require('../lib/events');\n\nvar WBEventsMixin = WBMixin.extend(events);\n\nmodule.exports = WBEventsMixin;\n",
    "'use strict';\n\nvar clone = require('../lib/clone');\nvar merge = require('../lib/merge');\nvar extend = require('../lib/extend');\nvar isEqual = require('../lib/isEqual');\nvar WBMixin = require('../WBMixin');\n\nvar WBStateMixin = WBMixin.extend({\n\n  'attributes': {},\n  'options': {},\n\n  'initialize': function (attributes, options) {\n\n    var self = this;\n    self.attributes = extend({}, self.defaults, attributes);\n    self.options = options || {};\n    self.changed = {};\n  },\n\n  'get': function (key) {\n    console.warn('getters are deprecated');\n    return this.attributes[key];\n  },\n\n  'set': function (key, val, options) {\n\n    var self = this;\n    if (key === null) {\n      return self;\n    }\n\n    var attrs, attr;\n    // Handle both `\"key\", value` and `{key: value}` -style arguments.\n    if (typeof key === 'object') {\n      attrs = key;\n      options = val;\n    } else {\n      attrs = {};\n      attrs[key] = val;\n    }\n\n    // default options are empty\n    options || (options = {});\n\n    // no need to track changes on options.silent\n    if (options.silent) {\n      merge(self.attributes, attr);\n    }\n    // For each `set` attribute, update or delete the current value.\n    else {\n      var changes = self.changes(attrs, options);\n      self._trigger(attrs, changes, options);\n    }\n\n    return self;\n  },\n\n  'unset': function (attr, options) {\n    return this.set(attr, undefined, extend({}, options, { 'unset': true }));\n  },\n\n  'clear': function (options) {\n    var self = this;\n    return self.set(self.defaults, options);\n  },\n\n  'changes': function (attrs, options) {\n\n    var self = this;\n    var key, val;\n    var changes = [];\n\n    var prev = clone(self.attributes, true);\n    var current = self.attributes;\n    self.changed = {};\n\n    for (key in attrs) {\n      val = attrs[key];\n      if (!isEqual(current[key], val)) {\n        changes.push(key);\n      }\n      if (!isEqual(prev[key], val)) {\n        self.changed[key] = val;\n      } else {\n        delete self.changed[key];\n      }\n\n      current[key] = options.unset ? undefined : val;\n    }\n\n    return changes;\n  },\n\n  '_trigger': function (attrs, changes, options) {\n\n    var self = this;\n    var current = self.attributes;\n\n    // if any changes found\n    // & if this is an EventEmitter,\n    // trigger the change events\n    var attr;\n    while (changes && changes.length && self.trigger) {\n      attr = changes.shift();\n      self.trigger('change:' + attr, self, current[attr], options);\n    }\n  }\n});\n\nmodule.exports = WBStateMixin;\n",
    "'use strict';\n\nvar WBMixin = require('../WBMixin');\nvar WBDeferred = require('../WBDeferred');\nvar when = require('../lib/when');\nvar toArray = require('../lib/toArray');\nvar forEach = require('../lib/forEach');\nvar delay = require('../lib/delay');\nvar defer = require('../lib/defer');\nvar functions = require('../lib/functions');\n\nvar WBUtilsMixin = WBMixin.extend({\n\n  'deferred': function () {\n    var self = this;\n    return new WBDeferred(self);\n  },\n\n  'when': function () {\n    var self = this;\n    return when.apply(self, arguments);\n  },\n\n  'defer': function (fn) {\n    var self = this;\n    var args = toArray(arguments);\n    // default context to self\n    args[1] = args[1] || this;\n    // support string names of functions on self\n    (typeof fn === 'string') && (args[0] = self[fn]);\n    return defer.apply(null, args);\n  },\n\n  'delay': function (fn) {\n    var self = this;\n    var args = toArray(arguments);\n    // default context to self\n    args[2] = args[2] || self;\n    // support string names of functions on self\n    (typeof fn === 'string') && (args[0] = self[fn]);\n    return delay.apply(null, args);\n  },\n\n  'forEach': function (collection, fn, context) {\n    var self = this;\n    // default context to self\n    context = context || self;\n    // support string names of functions on self\n    (typeof fn === 'string') && (fn = self[fn]);\n    forEach(collection, fn, context);\n  },\n\n  'functions': function (obj) {\n    return functions(obj || this);\n  }\n});\n\nmodule.exports = WBUtilsMixin;\n",
    "'use strict';\n\nmodule.exports = {\n  'ControllableMixin': require('./ControllableMixin'),\n  'ObservableHashMixin': require('./ObservableHashMixin'),\n  'WBBindableMixin': require('./WBBindableMixin'),\n  'WBDestroyableMixin': require('./WBDestroyableMixin'),\n  'WBEventsMixin': require('./WBEventsMixin'),\n  'WBStateMixin': require('./WBStateMixin'),\n  'WBUtilsMixin': require('./WBUtilsMixin')\n};"
  ],
  "sourceRoot": "file://"
}